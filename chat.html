<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üí¨ Chat | Jiji ya Chogoria</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7"></script>
<style>
  /* ====== RESET & BASE ====== */
  * { margin:0; padding:0; box-sizing:border-box; font-family:'Poppins', sans-serif; }
  body { background:#000; color:#fff; display:flex; justify-content:center; align-items:flex-start; min-height:100vh; }

  /* ====== CHAT CONTAINER ====== */
  .chat-container { display:flex; flex-direction:row; width:100%; max-width:1024px; min-height:100vh; background:#000; }

  /* ====== SIDEBAR ====== */
  .sidebar { width:300px; background:#111; border-right:1px solid #222; overflow-y:auto; transition:transform 0.3s ease; }
  .sidebar.hidden { transform:translateX(-100%); }
  .tab-btns { display:flex; border-bottom:1px solid #222; }
  .tab-btn { flex:1; padding:12px; text-align:center; cursor:pointer; color:#fff; transition:all 0.3s; }
  .tab-btn.active { background:#ff6600; color:#000; font-weight:bold; }
  .search-container { padding:10px; }
  .search-input { width:100%; padding:10px; border-radius:20px; border:none; background:#222; color:#fff; outline:none; }
  .conversations-container { padding:10px; }
  .conversation { display:flex; align-items:center; padding:8px; cursor:pointer; border-radius:10px; transition:background 0.2s; margin-bottom:5px; }
  .conversation:hover { background:#222; }
  .conversation-avatar { width:40px; height:40px; border-radius:50%; background:#333; display:flex; align-items:center; justify-content:center; font-weight:bold; margin-right:10px; position:relative; }
  .conversation-avatar.online::after { content:''; position:absolute; bottom:0; right:0; width:10px; height:10px; background:#0f0; border-radius:50%; border:2px solid #000; }
  .conversation-details { flex:1; display:flex; flex-direction:column; }
  .conversation-header { display:flex; justify-content:space-between; }
  .conversation-name { font-weight:bold; font-size:14px; color:#ff6600; }
  .conversation-preview { font-size:13px; color:#aaa; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .conversation-time { font-size:12px; color:#888; }
  .unread-indicator { background:#ff6600; color:#000; font-size:12px; padding:2px 6px; border-radius:10px; margin-left:5px; }

  /* ====== CHAT AREA ====== */
  .chat-area { flex:1; display:flex; flex-direction:column; background:#000; }
  .chat-header { display:none; align-items:center; padding:10px; border-bottom:1px solid #222; background:#111; }
  .back-btn { display:none; background:none; border:none; color:#fff; font-size:20px; cursor:pointer; margin-right:10px; }
  .chat-user-avatar { width:40px; height:40px; border-radius:50%; background:#333; display:flex; align-items:center; justify-content:center; font-weight:bold; margin-right:10px; position:relative; }
  .chat-user-avatar.online::after { content:''; position:absolute; bottom:0; right:0; width:10px; height:10px; background:#0f0; border-radius:50%; border:2px solid #000; }
  .chat-user-info { display:flex; flex-direction:column; }
  .chat-user-name { font-weight:bold; color:#ff6600; }
  .chat-user-status { font-size:12px; color:#888; }
  .messages-container { flex:1; overflow-y:auto; padding:10px; display:flex; flex-direction:column; gap:8px; }
  .message { max-width:80%; padding:10px; border-radius:15px; position:relative; word-wrap:break-word; }
  .message.sent { background:#ff6600; color:#000; align-self:flex-end; border-bottom-right-radius:3px; }
  .message.received { background:#222; color:#fff; align-self:flex-start; border-bottom-left-radius:3px; }
  .message-bubble { display:flex; flex-direction:column; }
  .message-header { font-size:12px; color:#888; margin-bottom:4px; display:flex; justify-content:space-between; }
  .message-content { font-size:14px; }
  .delete-btn { background:transparent; border:none; color:#ff3300; cursor:pointer; margin-left:5px; font-size:12px; }
  .message-time { font-size:11px; color:#888; margin-top:3px; text-align:right; }

  /* ====== INPUT AREA ====== */
  .message-input-container { display:flex; padding:10px; border-top:1px solid #222; background:#111; }
  .message-form { display:flex; }
  .message-input { flex:1; padding:10px; border-radius:20px; border:none; background:#222; color:#fff; outline:none; margin-right:10px; }
  .send-btn { padding:10px 20px; background:#ff6600; border:none; border-radius:20px; color:#000; font-weight:bold; cursor:pointer; transition:all 0.3s; }
  .send-btn:hover { transform:scale(1.05); box-shadow:0 0 10px #ff6600; }

  /* ====== LOADING & EMPTY ====== */
  .loading-spinner { text-align:center; padding:20px; color:#ff6600; }
  .no-messages, .no-conversations, .error-message { text-align:center; color:#888; padding:20px; }

  /* ====== MOBILE ====== */
  @media (max-width:768px) {
    .chat-container { flex-direction:column; }
    .sidebar { width:100%; max-height:250px; overflow-y:auto; }
    .chat-area { flex:1; }
    .back-btn { display:block; }
  }

  /* ====== TOAST ====== */
  .toast { position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:#ff6600; color:#000; padding:10px 20px; border-radius:20px; display:flex; gap:6px; align-items:center; font-weight:bold; animation:slideIn 0.3s ease; z-index:999; }
  .toast.error { background:#ff3300; color:#fff; }
  .toast.warning { background:#ffaa00; color:#000; }
  @keyframes slideIn { from{opacity:0; transform:translate(-50%,20px);} to{opacity:1; transform:translate(-50%,0);} }
  @keyframes slideOut { from{opacity:1;} to{opacity:0;} }
</style>
</head>
<body>
<div class="chat-container">
  <!-- SIDEBAR -->
  <div class="sidebar" id="sidebar">
    <div class="tab-btns">
      <div class="tab-btn active" data-tab="inbox">Inbox</div>
      <div class="tab-btn" data-tab="community">Community</div>
    </div>
    <div class="search-container">
      <input type="text" class="search-input" placeholder="Search conversations...">
    </div>
    <div class="conversations-container" id="conversations-container">
      <div class="loading-spinner">Loading conversations...</div>
    </div>
  </div>

  <!-- CHAT AREA -->
  <div class="chat-area">
    <div class="chat-header" id="chat-header">
      <button class="back-btn" id="back-to-inbox">‚Üê</button>
      <div class="chat-user-avatar" id="chat-user-avatar">U</div>
      <div class="chat-user-info">
        <div class="chat-user-name" id="chat-user-name">Username</div>
        <div class="chat-user-status" id="chat-user-status">Offline</div>
      </div>
    </div>
    <div class="messages-container" id="messages-container">
      <div class="no-messages">Select a conversation to start chatting</div>
    </div>
    <div class="message-input-container" id="message-input-container">
      <form class="message-form" id="message-form">
        <input type="text" class="message-input" id="message-input" placeholder="Type your message...">
        <button type="submit" class="send-btn">Send</button>
      </form>
    </div>
  </div>
</div>

<script>
  // Initialize Supabase
  const supabaseUrl = 'https://lrezerxsbuekkhmpverr.supabase.co';
  const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxyZXplcnhzYnVla2tobXB2ZXJyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNTI3MjMsImV4cCI6MjA3MzkyODcyM30.96senppPRMHveFi2ouDPDqhh17XIwxsLvA4U0rvjU9g';
  const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

  // Cache DOM elements
  const elements = {
    sidebar: document.getElementById('sidebar'),
    conversationsContainer: document.getElementById('conversations-container'),
    messagesContainer: document.getElementById('messages-container'),
    messageForm: document.getElementById('message-form'),
    messageInput: document.getElementById('message-input'),
    messageInputContainer: document.getElementById('message-input-container'),
    chatHeader: document.getElementById('chat-header'),
    chatUserAvatar: document.getElementById('chat-user-avatar'),
    chatUserName: document.getElementById('chat-user-name'),
    chatUserStatus: document.getElementById('chat-user-status'),
    backToInboxBtn: document.getElementById('back-to-inbox'),
    searchInput: document.querySelector('.search-input'),
    tabBtns: document.querySelectorAll('.tab-btn')
  };

  // State management
  let currentUser = null;
  let activeTab = 'inbox';
  let activeConversation = null;
  let onlineUsers = new Set();
  let isMobile = () => window.innerWidth <= 768;

  // Toggle sidebar on mobile
  function toggleSidebar() {
    if (isMobile()) {
      elements.sidebar.classList.toggle('hidden');
    }
  }

  // Toast notification function
  function showToast(message, type = 'success') {
    document.querySelectorAll('.toast').forEach(toast => toast.remove());
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    
    const icons = {
      success: '‚úÖ',
      error: '‚ùå',
      warning: '‚ö†Ô∏è'
    };
    
    toast.innerHTML = `<span>${icons[type] || ''}</span> <span>${message}</span>`;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.4s ease forwards';
      setTimeout(() => toast.remove(), 400);
    }, 3000);
  }

  // Check authentication and ensure profile exists
  async function checkAuth() {
    try {
      const { data: { user }, error } = await supabase.auth.getUser();
      
      if (error || !user) {
        showToast('Please log in to access the chat üòï', 'error');
        window.location.href = 'index.html';
        return null;
      }

      const { data: profile } = await supabase
        .from('profiles')
        .select('id, full_name')
        .eq('id', user.id)
        .single();
        
      if (!profile) {
        await supabase
          .from('profiles')
          .insert([{
            id: user.id,
            full_name: user.user_metadata?.full_name || user.email
          }]);
      }
      
      return user;
    } catch (authError) {
      console.error('Authentication error:', authError);
      showToast('Authentication failed. Please log in again.', 'error');
      window.location.href = 'index.html';
      return null;
    }
  }

  // Load conversations (both inbox and community)
  async function loadConversations() {
    try {
      elements.conversationsContainer.innerHTML = '<div class="loading-spinner">Loading conversations...</div>';

      const { data: userData } = await supabase.auth.getUser();
      const currentUserId = userData?.user?.id;

      let query = supabase
        .from('messages')
        .select(`
          id,
          content,
          user_id,
          recipient_id,
          created_at,
          profiles!messages_user_id_fkey(full_name),
          recipient:profiles!messages_recipient_id_fkey(full_name)
        `);

      if (activeTab === 'inbox') {
        query = query
          .eq('is_private', true)
          .or(`user_id.eq.${currentUserId},recipient_id.eq.${currentUserId}`);
      } else {
        query = query
          .eq('is_private', false);
      }

      const { data, error } = await query.order('created_at', { ascending: false });

      if (error) {
        throw error;
      }

      elements.conversationsContainer.innerHTML = '';
      
      if (data.length === 0) {
        const emptyMessage = activeTab === 'inbox' 
          ? 'No conversations yet. Start a private chat! üì©' 
          : 'No community messages yet. Start the conversation! üòä';
        
        elements.conversationsContainer.innerHTML = `<div class="no-conversations">${emptyMessage}</div>`;
        return;
      }

      const fragment = document.createDocumentFragment();
      
      if (activeTab === 'inbox') {
        // Process inbox conversations
        const conversations = {};
        
        data.forEach(message => {
          const otherUserId = message.user_id === currentUserId ? message.recipient_id : message.user_id;
          const otherUserName = message.user_id === currentUserId 
            ? (message.recipient?.full_name || 'Unknown') 
            : (message.profiles?.full_name || 'Unknown');
            
          if (!conversations[otherUserId]) {
            conversations[otherUserId] = {
              full_name: otherUserName,
              lastMessage: message.content,
              lastTime: message.created_at,
              unread: message.user_id !== currentUserId && !message.is_read
            };
          }
        });
        
        Object.entries(conversations).forEach(([userId, convo]) => {
          const conversationEl = createConversationElement(userId, convo);
          fragment.appendChild(conversationEl);
        });
      } else {
        // Process community messages
        data.forEach(message => {
          const conversationEl = createCommunityMessageElement(message);
          fragment.appendChild(conversationEl);
        });
      }

      elements.conversationsContainer.appendChild(fragment);
    } catch (error) {
      console.error('Error loading conversations:', error);
      elements.conversationsContainer.innerHTML = `<div class="error-message">‚ö†Ô∏è ${error.message}</div>`;
      showToast('Error loading conversations üòï', 'error');
    }
  }

  // Create conversation element for inbox
  function createConversationElement(userId, convo) {
    const conversationEl = document.createElement('div');
    conversationEl.className = 'conversation';
    conversationEl.setAttribute('data-user-id', userId);
    
    const isOnline = onlineUsers.has(userId);
    
    conversationEl.innerHTML = `
      <div class="conversation-avatar ${isOnline ? 'online' : ''}">
        ${escapeHtml(convo.full_name.charAt(0).toUpperCase())}
      </div>
      <div class="conversation-details">
        <div class="conversation-header">
          <div class="conversation-name">${escapeHtml(convo.full_name)}</div>
          <div class="conversation-time">${formatTime(convo.lastTime)}</div>
        </div>
        <div class="conversation-preview">${escapeHtml(convo.lastMessage)}</div>
      </div>
      ${convo.unread ? '<div class="unread-indicator">1</div>' : ''}
    `;
    
    conversationEl.addEventListener('click', () => {
      loadPrivateMessages(userId, convo.full_name);
    });
    
    return conversationEl;
  }

  // Create conversation element for community
  function createCommunityMessageElement(message) {
    const conversationEl = document.createElement('div');
    conversationEl.className = 'conversation';
    conversationEl.setAttribute('data-message-id', message.id);
    
    const isOnline = onlineUsers.has(message.user_id);
    
    conversationEl.innerHTML = `
      <div class="conversation-avatar ${isOnline ? 'online' : ''}">
        ${escapeHtml(message.profiles?.full_name?.charAt(0).toUpperCase() || 'U')}
      </div>
      <div class="conversation-details">
        <div class="conversation-header">
          <div class="conversation-name">${escapeHtml(message.profiles?.full_name || 'Unknown')}</div>
          <div class="conversation-time">${formatTime(message.created_at)}</div>
        </div>
        <div class="conversation-preview">${escapeHtml(message.content)}</div>
      </div>
    `;
    
    conversationEl.addEventListener('click', () => {
      loadCommunityChat();
    });
    
    return conversationEl;
  }

  // Load messages (both private and community)
  async function loadMessages(recipientId = null, isCommunity = false) {
    try {
      elements.messagesContainer.innerHTML = '<div class="loading-spinner">Loading messages...</div>';

      const { data: userData } = await supabase.auth.getUser();
      const currentUserId = userData?.user?.id;

      let query = supabase
        .from('messages')
        .select(`
          id,
          content,
          user_id,
          created_at,
          profiles!messages_user_id_fkey(full_name)
        `);

      if (isCommunity) {
        query = query.eq('is_private', false);
      } else {
        query = query
          .eq('is_private', true)
          .or(`and(user_id.eq.${currentUserId},recipient_id.eq.${recipientId}),and(user_id.eq.${recipientId},recipient_id.eq.${currentUserId})`);
      }

      const { data, error } = await query.order('created_at', { ascending: true });

      if (error) {
        throw error;
      }

      elements.messagesContainer.innerHTML = '';

      if (data.length === 0) {
        elements.messagesContainer.innerHTML = '<div class="no-messages">No messages yet. Start the conversation! üòä</div>';
        return;
      }

      const fragment = document.createDocumentFragment();
      
      data.forEach(message => {
        const isCurrentUser = message.user_id === currentUserId;
        const messageEl = document.createElement('div');
        messageEl.className = `message ${isCurrentUser ? 'sent' : 'received'}`;
        
        const deleteButton = isCurrentUser
          ? `<button class="delete-btn" data-id="${message.id}">üóëÔ∏è</button>`
          : '';

        if (isCommunity) {
          messageEl.innerHTML = `
            <div class="message-bubble">
              <div class="message-header">
                <span class="message-sender">${escapeHtml(message.profiles?.full_name || 'Unknown')}</span>
                <span class="message-time">${formatTime(message.created_at)}</span>
              </div>
              <div class="message-content">${escapeHtml(message.content)}</div>
              <div class="message-time">
                ${deleteButton}
              </div>
            </div>
          `;
        } else {
          messageEl.innerHTML = `
            <div class="message-bubble">
              <div class="message-content">${escapeHtml(message.content)}</div>
              <div class="message-time">
                ${formatTime(message.created_at)}
                ${deleteButton}
              </div>
            </div>
          `;
        }
        
        fragment.appendChild(messageEl);
      });

      elements.messagesContainer.appendChild(fragment);
      
      // Auto-scroll to bottom
      setTimeout(() => {
        elements.messagesContainer.scrollTop = elements.messagesContainer.scrollHeight;
      }, 100);

      // Add delete button event listeners
      document.querySelectorAll('.delete-btn').forEach(button => {
        button.addEventListener('click', async (e) => {
          e.stopPropagation();
          if (confirm('Are you sure you want to delete this message?')) {
            await deleteMessage(button.getAttribute('data-id'));
          }
        });
      });

      // Mark messages as read for private chats
      if (!isCommunity && recipientId) {
        await markMessagesAsRead(recipientId);
      }
    } catch (error) {
      console.error('Error loading messages:', error);
      elements.messagesContainer.innerHTML = `<div class="error-message">‚ö†Ô∏è ${error.message}</div>`;
      showToast('Error loading messages üòï', 'error');
    }
  }

  // Load private messages for a specific user
  async function loadPrivateMessages(recipientId, recipientName) {
    activeConversation = recipientId;
    
    // Show chat header and input
    elements.chatHeader.style.display = 'flex';
    elements.messageInputContainer.style.display = 'flex';
    
    // Update chat header
    elements.chatUserAvatar.textContent = escapeHtml(recipientName.charAt(0).toUpperCase());
    elements.chatUserName.textContent = escapeHtml(recipientName);
    elements.chatUserStatus.textContent = onlineUsers.has(recipientId) ? 'Online' : 'Offline';
    
    // Hide sidebar on mobile
    if (isMobile()) {
      elements.sidebar.classList.add('hidden');
    }

    await loadMessages(recipientId, false);
  }

  // Load community chat
  async function loadCommunityChat() {
    activeConversation = 'community';
    
    // Show chat header and input
    elements.chatHeader.style.display = 'flex';
    elements.messageInputContainer.style.display = 'flex';
    
    // Update chat header
    elements.chatUserAvatar.textContent = 'üí¨';
    elements.chatUserName.textContent = 'Community Chat';
    elements.chatUserStatus.textContent = 'Everyone';
    
    // Hide sidebar on mobile
    if (isMobile()) {
      elements.sidebar.classList.add('hidden');
    }

    await loadMessages(null, true);
  }

  // Mark messages as read
  async function markMessagesAsRead(senderId) {
    try {
      const { data: userData } = await supabase.auth.getUser();
      const currentUserId = userData?.user?.id;

      await supabase
        .from('messages')
        .update({ is_read: true })
        .eq('recipient_id', currentUserId)
        .eq('user_id', senderId)
        .eq('is_read', false);
    } catch (error) {
      console.error('Error marking messages as read:', error);
    }
  }

  // Delete message
  async function deleteMessage(messageId) {
    try {
      const { data: userData } = await supabase.auth.getUser();
      const currentUserId = userData?.user?.id;
      
      // Verify the message belongs to the current user
      const { data: message } = await supabase
        .from('messages')
        .select('user_id')
        .eq('id', messageId)
        .single();
        
      if (!message || message.user_id !== currentUserId) {
        showToast('You can only delete your own messages', 'error');
        return;
      }
      
      // Delete the message
      const { error } = await supabase
        .from('messages')
        .delete()
        .eq('id', messageId);

      if (error) {
        throw error;
      }

      showToast('Message deleted successfully üóëÔ∏è');
      
      // Reload messages based on current conversation
      if (activeConversation === 'community') {
        loadCommunityChat();
      } else {
        const recipientName = elements.chatUserName.textContent;
        loadPrivateMessages(activeConversation, recipientName);
      }
    } catch (error) {
      console.error('Error deleting message:', error);
      showToast(error.message, 'error');
    }
  }

  // Send a message
  elements.messageForm?.addEventListener('submit', async (e) => {
    e.preventDefault();

    try {
      const user = await checkAuth();
      if (!user) return;

      const content = elements.messageInput.value.trim();
      if (!content) {
        showToast('Please enter a message', 'error');
        return;
      }

      const isPrivate = activeConversation !== 'community';
      
      const messageData = {
        content,
        user_id: user.id,
        is_private: isPrivate,
        is_read: false
      };

      if (isPrivate) {
        messageData.recipient_id = activeConversation;
      }

      const { error } = await supabase
        .from('messages')
        .insert([messageData]);

      if (error) {
        throw error;
      }

      elements.messageInput.value = '';
      
      // Reload messages based on current conversation
      if (isPrivate) {
        const recipientName = elements.chatUserName.textContent;
        loadPrivateMessages(activeConversation, recipientName);
      } else {
        loadCommunityChat();
      }
    } catch (error) {
      console.error('Error sending message:', error);
      showToast(error.message, 'error');
    }
  });

  // Tab switching
  elements.tabBtns.forEach(button => {
    button.addEventListener('click', () => {
      elements.tabBtns.forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');
      activeTab = button.getAttribute('data-tab');
      
      // Reset conversation
      activeConversation = null;
      elements.chatHeader.style.display = 'none';
      elements.messageInputContainer.style.display = 'none';
      elements.messagesContainer.innerHTML = '<div class="no-messages">Select a conversation to start chatting</div>';
      
      // Load conversations
      loadConversations();
    });
  });

  // Back to inbox button
  elements.backToInboxBtn?.addEventListener('click', () => {
    elements.sidebar.classList.remove('hidden');
    elements.chatHeader.style.display = 'none';
    elements.messageInputContainer.style.display = 'none';
    elements.messagesContainer.innerHTML = '<div class="no-messages">Select a conversation to start chatting</div>';
    activeConversation = null;
  });

  // Initialize app
  async function initApp() {
    try {
      currentUser = await checkAuth();
      if (!currentUser) return;

      // Set up real-time subscriptions
      setupRealtimeSubscriptions();

      // Check if we're coming from a product page
      const sellerId = sessionStorage.getItem('chatSellerId');
      const sellerName = sessionStorage.getItem('chatSellerName');
      const productTitle = sessionStorage.getItem('chatProductTitle');

      if (sellerId && sellerName && productTitle) {
        // Switch to inbox tab
        elements.tabBtns.forEach(btn => btn.classList.remove('active'));
        document.querySelector('.tab-btn[data-tab="inbox"]').classList.add('active');
        activeTab = 'inbox';
        
        // Load conversation with seller
        await loadPrivateMessages(sellerId, sellerName);
        
        // Pre-fill message input
        elements.messageInput.value = `Hi ${sellerName}, I'm interested in your product: ${productTitle}`;
        
        // Clear session storage
        sessionStorage.removeItem('chatSellerId');
        sessionStorage.removeItem('chatSellerName');
        sessionStorage.removeItem('chatProductTitle');
      } else {
        // Load inbox conversations by default
        loadConversations();
      }
    } catch (error) {
      console.error('Initialization error:', error);
      showToast('Failed to initialize the chat. Please refresh the page.', 'error');
    }
  }

  // Setup real-time subscriptions
  function setupRealtimeSubscriptions() {
    // Set up real-time subscriptions for online status
    const channel = supabase.channel('online-users');
    
    channel
      .on('presence', { event: 'sync' }, () => {
        const newState = channel.presenceState();
        onlineUsers = new Set(Object.keys(newState));
        
        updateOnlineStatus();
        
        // Update conversation list
        if (!activeConversation) {
          loadConversations();
        }
      })
      .on('presence', { event: 'join' }, ({ key }) => {
        onlineUsers.add(key);
        updateOnlineStatus();
      })
      .on('presence', { event: 'leave' }, ({ key }) => {
        onlineUsers.delete(key);
        updateOnlineStatus();
      })
      .subscribe(async (status) => {
        if (status === 'SUBSCRIBED' && currentUser) {
          await channel.track({
            user_id: currentUser.id,
            online_at: new Date().toISOString()
          });
        }
      });

    // Set up real-time subscription for messages
    supabase
      .channel('messages')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'messages' }, () => {
        if (activeConversation === 'community') {
          loadCommunityChat();
        } else if (activeConversation) {
          const recipientName = elements.chatUserName.textContent;
          loadPrivateMessages(activeConversation, recipientName);
        } else {
          loadConversations();
        }
      })
      .subscribe();
  }

  // Update online status in UI
  function updateOnlineStatus() {
    if (activeConversation && activeConversation !== 'community') {
      const statusElement = elements.chatUserStatus;
      const avatarElement = elements.chatUserAvatar;
      
      if (statusElement) {
        statusElement.textContent = onlineUsers.has(activeConversation) ? 'Online' : 'Offline';
      }
      
      if (avatarElement) {
        if (onlineUsers.has(activeConversation)) {
          avatarElement.classList.add('online');
        } else {
          avatarElement.classList.remove('online');
        }
      }
    }
  }

  // Helper functions
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function formatTime(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    
    // If it's today, show time only
    if (date.toDateString() === now.toDateString()) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    
    // If it's yesterday, show "Yesterday"
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.toDateString() === yesterday.toDateString()) {
      return 'Yesterday';
    }
    
    // Otherwise, show date
    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
  }

  // Initialize app when DOM is fully loaded
  document.addEventListener('DOMContentLoaded', initApp);
  
  // Handle orientation changes for mobile devices
  window.addEventListener('orientationchange', function() {
    setTimeout(() => {
      if (activeConversation === 'community') {
        loadCommunityChat();
      } else if (activeConversation) {
        const recipientName = elements.chatUserName.textContent;
        loadPrivateMessages(activeConversation, recipientName);
      }
    }, 300);
  });
</script>
</body>
</html>